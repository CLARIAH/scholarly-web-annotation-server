# RDFa Annotation Client - Annotation Data Models

For the RDFa Annotation Client and its communicating with the server (e.g. Alexandria) we need to establish a data model for the annotations. The idea is to base this on the [W3C Web Annotation Model](https://www.w3.org/TR/annotation-model/#web-annotation-framework).



## Basic model
The most basic target is an entire resource, such as a single van Gogh letter.

```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1484229754,
  "body": [
    {
      "vocabulary": "DBpedia",
      "value": "Communication",
      "purpose": "classifying",
      "id": "http://dbpedia.org/resource/Communication"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Text",
      "source": "urn:vangogh:let001"
    }
  ],
  "id": "urn:uuid:e9d01a37-9dca-4f96-bc6a-5c44012d6e9e"
}
```

Some discussion points:

+ Marijn: the value of the `created` property is generated by the annotation server. In the current prototype I'm using seconds since epoch, but Alexandria probably has a different format. 
+ Marijn: In the body I've added a few extra properties, i.e. `type`, `value` and `vocabulary` so that the annotation describes itself more (easier to interpret) and the info can be displayed to the user without needing to do a DBpedia lookup.
+ Marijn: The motivation `classifying` is taken from the [official W3C list of motivations](https://www.w3.org/TR/annotation-model/#motivation-and-purpose).  I don't like this interpretation of *motivation*. Classifying is not a motivation, i.e., it doesn't say why or in what context I'm classifying the target. The W3C framework also has a property `purpose` which it only allows as the property of a body of type `TextualBody` or `SpecificResource`. I would prefer to use `purpose` as a property on all bodies, since that conveys better what the purpose of the annotation is. When classifying, the purpose of an annotation is to classify a resource. It also makes more sense with multiple bodies, allowing a different purpose per annotation body, e.g. classifying and commenting in a single annotation have different purposes.


## Fragment selector
When the annotation targets a resource that is part of a larger resource, a [fragment selector](https://www.w3.org/TR/annotation-model/#fragment-selector) is used to refine the target. 

In the example below, the `receiver` metadata of the `letter` is the annotation target, identified through a `FragmentSelector` on the `letter`:
```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1483949925,
  "body": [
    {
      "vocabulary": "DBpedia",
      "value": "Theo van Gogh (art dealer)",
      "purpose": "classifying",
      "id": "http://dbpedia.org/resource/Theo_van_Gogh_(art_dealer)"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Text",
      "source": "urn:vangogh:let001",
      "selector": {
        "conformsTo": "http://tools.ietf.org/rfc/rfc3870",
        "value": "urn:vangogh:let001.receiver",
        "type": "FragmentSelector"
      }
    }
  ],
  "id": "urn:uuid:8f62be7d-de56-464b-8d9a-5fb0b69fc00b"
}
```

Discussion points:

+ Marijn: the reason to use a fragment selector is that the annotation target makes explicit that `urn:vangogh:let001.receiver` is part of `urn:vangogh:let001`. For retrieving annotations by resource, it's now trivial to ask the annotation server to return all annotations related to the letter `urn:vangogh:let001`. Of course, this doesn't solve retrieval of annotations for resource hierarchies with more than two levels (e.g. van Gogh letter collection > van Gogh letter > receiver, how to get all annotations for all letters in the collection from the annotation sesrver, assuming the annotation server has no knowledge of the resource hierarchy).
+ The value of the `conformsTo` property is taken from a fixed list proposed by W3C. Perhaps it makes more sense here to refer to the *Van Gogh ontology* here.

## Text selectors
Instead of selecting a fragment of the resource as target, a user can also select a text fragment as the target. There are two options for text selectors:

1. [text position selector](https://www.w3.org/TR/annotation-model/#text-quote-selector): represents the target through the start and end offsets of the selected text in the resource, e.g. start at character offset 76, end at character offset 84.
2. [text quote selector](https://www.w3.org/TR/annotation-model/#text-position-selector): represents the target through the string of selected text, in combination with short strings before and after it to provide context.

In the two examples below, the same text selection `September 29` is targeted, first with a `TextPositionSelector`, then with a `TextQuoteSelector`:

#### Text position selector

```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1483959766,
  "body": [
    {
      "vocabulary": "DBpedia",
      "value": "September 29",
      "purpose": "classifying",
      "id": "http://dbpedia.org/resource/September_29"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Text",
      "source": "urn:vangogh:let001",
      "selector": {
         "start": 164,
         "type": "TextPositionSelector",
         "end": 176
      }
    }
  ],
  "id": "urn:uuid:3a006d50-15c9-4647-b325-77e6bbb24ad5"
}
```

#### Text quote selector

```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1484230981,
  "body": [
    {
      "vocabulary": "DBpedia",
      "value": "September 29",
      "purpose": "classifying",
      "id": "http://dbpedia.org/resource/September_29"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Text",
      "source": "urn:vangogh:let001",
      "selector": {
        "prefix": ". The Hague, Sunday, ",
        "suffix": " 1872\n\nSource status:",
        "type": "TextQuoteSelector",
        "exact": "29 September"
      }
    }
  ],
  "id": "urn:uuid:9e808982-33ad-45b4-859f-e385352ca6cd"
}
```

Discussion points:

+ Marijn: There are pros and cons with each selector type. 
  + The position selector is more precise and robust against the problem of identifying the right target when there are repeated text fragments (typical in e.g. poems and lyrics and common phrases in long texts). But if the same resource is displayed in a different viewer with different choices of what to enrich (e.g. inclusion of `IgnorableElement` type and `SelectWholeElement` property), the offsets can be different, so the position selector targets a different piece of text. It also makes the annotation itself harder to interpret, since the textual target is not included.
  + The quote selector has the reverse pros and cons. It makes the annotation easier to interpret and is robust against changes in RDFa enrichment choices, but can't resolve target ambiguity when the quote and its context occurs multiple times in the target.
+ However, it is possible to combine the two text selectors, see [below](#multiple_refinedby).

## Combining fragment and text selectors

It is also possible that the target is a selected text fragment that is part of sub-resource of the whole or top-level resource, e.g. a passage (text selection) in a paragraph (sub-resource) in a letter (top-level resource). 

In that case [selector refinement](https://www.w3.org/TR/annotation-model/#refinement-of-selection) is used. In the above case, a `FragmentSelector` is `refinedBy` a `TextPositionSelector` and/or a `TextQuoteSelector`. The annotation below targets the passage *droppeltjes* within the 4th `paragraph` of the `letter`:

```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1484220285,
  "body": [
    {
      "vocabulary": "DBpedia",
      "value": "Precipitation (meteorology)",
      "purpose": "classifying",
      "id": "http://dbpedia.org/resource/Precipitation_(meteorology)"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Text",
      "source": "urn:vangogh:let001",
      "selector": {
        "conformsTo": "http://tools.ietf.org/rfc/rfc3870",
        "value": "urn:vangogh:let001:p.4",
        "type": "FragmentSelector",
        "refinedBy": [
          {
            "prefix": "had, en tusschen de ",
            "suffix": " door toch nog al ee",
            "type": "TextQuoteSelector",
            "exact": "droppeltjes"
          }
        ]
      }
    }
  ],
  "id": "urn:uuid:46c8fd5f-d038-497d-a7a3-1814b8d65201"
}
```

Discussion points:

+ Marijn: the W3C model seems to allow at most one selector and an additional level of refinement (so max 3 levels: `source`, `selector.value` and `refinedBy`). The nice thing here is that it allows specifying the top level resource (`urn:vangogh:let001`), the most specific targeted part that *contains* the selected text fragment (`urn:vangogh:let001:p.4`) and the text selection (*droppeltjes*). This allows search on all three parts to retrieve relevant annotations.

## <a name="multiple_refinedby"></a>Improving robustness: combining text position and text quote selection

When using `refinedBy` in the W3C model, it is possible to use multiple refinements to indicate the same target. That is, all refinement selectors should represent the same target. 

The annotation below combines `TextPositionSelector` and `TextQuoteSelector` representing the same passage *droppeltjes*:

```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1484220285,
  "body": [
    {
      "vocabulary": "DBpedia",
      "value": "Precipitation (meteorology)",
      "purpose": "classifying",
      "id": "http://dbpedia.org/resource/Precipitation_(meteorology)"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Text",
      "source": "urn:vangogh:let001",
      "selector": {
        "conformsTo": "http://tools.ietf.org/rfc/rfc3870",
        "value": "urn:vangogh:let001:p.4",
        "type": "FragmentSelector",
        "refinedBy": [
          {
            "prefix": "had, en tusschen de ",
            "suffix": " door toch nog al ee",
            "type": "TextQuoteSelector",
            "exact": "droppeltjes"
          },
          {
            "start": 54,
            "type": "TextPositionSelector",
            "end": 65
          }
        ]
      }
    }
  ],
  "id": "urn:uuid:46c8fd5f-d038-497d-a7a3-1814b8d65201"
}
```

Discussion points:

+ Marijn: This allows bootstrapping the alignment between information about the target stored in the annotation and the target in the resource itself. E.g. with a combination of text position and text quote it is possible to identify changes in how the resource is displayed. If the text in the displayed resource corresponding to the position selector no longer corresponds to the text in the quote selector, the client knows that RDFa structure has changed and can look for the quoted text nearest to the stored positions. 


## Annotating Audiovisual Resources

The same data model can be used to annotate audiovisual resources, as long as they are accompanied by RDFa information, in e.g. a `<div>` element that surrounds the video or the time bar in which the start and end selectors are displayed.

```json
{
  "@context": "http://www.w3.org/ns/anno.jsonld",
  "created": 1484229754,
  "body": [
    {
      "vocabulary": "GTAA",
      "value": "Waterbronnen",
      "purpose": "classifying",
      "id": "http://data.beeldengeluid.nl/gtaa/28667"
    }
  ],
  "motivation": "classifying",
  "creator": "marijn",
  "type": "Annotation",
  "target": [
    {
      "type": "Video",
      "source": "http://player.vimeo.com/video/110756897",
      "selector": {
        "type": "FragmentSelector",
        "conformsTo": "http://www.w3.org/TR/media-frags/",
        "value": "#t=149.391,188.939"
      }
    }
  ],
  "id": "urn:uuid:e9d01a37-9dca-4f96-bc6a-5c44012d6e9e"
}
```


## Additional properties

+ **annotation context**: The W3C model allows specifying agents involved in the annotation process:
  + **annotation client**: e.g. client name and version, github repository,
  + **annotation server**: e.g. server name and version, API location,
  + **location of resource viewer**: i.e. URL of web site that displays the resource and embeds the annotation client.
+ **Layer/Tier support**: for linguistic analysis and analysis of time-based media (e.g. video, audio), annotation tools offer annotations in tiers. Linguistic annotation is often in the form of different layers for part-of-speech tags, syllables, phonemes, phrases or named entities. This ties individual annotations together in an ordered list (e.g. the part-of-speech tags of all the words in a text, or the shot boundaries of a film). The W3C model supports the [collection of annotations as an ordered list](https://www.w3.org/TR/annotation-model/#collections). The *order* property enforces non-overlapping annotations, which fits with the typical understanding of tiered annotations in tools like [ELAN](https://tla.mpi.nl/tools/tla-tools/elan/), [Atlas.ti](http://atlasti.com/) and [NVivo](http://www.qsrinternational.com/).

#### Extensions to the W3C model

The W3C model allows for extensions to the basic framework. We could consider adding (or at least leaving room for) properties capturing information about:

+ **Ontology/vocabulary**: controlled vocabularies used in the RDFa enriched resource (e.g. van Gogh letters ontology). This could in principle be used by the annotation server to reason about relationships between stored annotations and the resources they target.
+ **Research context**: e.g. research project, questions, methodology, intention of use. This allows further interpretation of the annotations and why certain choices were made by the annotator.
